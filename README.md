# Лабораторная работа №1. Калькулятор на питоне (M1).

## Введение
Если вам нужно посчитать какое-то арифметическое выражение, то смело юзайте этот калькулятор. Особенности описаны далее.

## Структура проекта

 <pre>
    .
    ├── lab1     # Кодовая база лабораторной работы
    │   ├── src/    # Исходный код
    │   │   ├── _init_.py    
    │   │   ├── calculate.py  # Реализация отлова большинства ошибок
    │   │   ├── constants.py  # Константы
    │   │   ├── errors.py     # Собственные классы с ошибками
    │   │   ├── main.py       # Точка входа в приложение
    │   │   ├── parser.py     # Реализация вычисления значения математического выражение (рекурсивный спуск)
    │   │   ├── tokenizer.py  # Реализация токенизации как самого выражения, так и отдельного токена
    │   │   
    │   ├── tests/      # Unit тесты
    │   │   ├── _init_.py
    │   │   ├── test_calculate.py  # PyTest
    │   │  
    │   ├── uv.lock                            # зависимости проекта
    │   ├── .gitignore                         # git ignore файл
    │   ├──.pre-commit-config.yaml             # Средства автоматизации проверки кодстайла
    │   ├── README.md                          # Описание проекта, с описанием файлов и с титульником о том,
                                               # что и какая задача
</pre>


## Описание работы калькулятора
Вызывается функция **main**, далее пользователь вводит выражение. Обработка полученных данных уходит в файл [calculate.py](src/calculate.py).

В этом файле сначала вызывается функция **tokenizer** из файла [tokenizer.py](src/tokenizer.py). После этого идет проверка на ошибки. Чуть ниже
будет расписаны ошибки в порядке убывания их приоритета. Далее запускается входная функция в рекурсивный спуск **expr**, расположенная в файле [parser](src/parser.py).
Выполняется вычисление значения арифметического выражения. Однако в процессе может возникнуть ряд ошибок: ZeroDivisionError, NegativeSqrtError, IntegerOperationError, ValueError.
Если все расчеты были выполнены без ошибок, то возвращается значение арифметического выражения.
(Примечание: в программе все вычисления проводятся в типе float и возвращает **expr** значение арифметического выражения тоже во float). Однако перед выводом проверяется,
если число целое представленное в типе float, то выводится int представление числа, иначе float. При выводе float так же проверяется наличие более двух знаков после запятой.
Если более двух, то выводится запрос пользователю ввести или до какого числа после запятой округлить число, или ввести ничего, или не число,
чтобы вывести значение арифметического выражения без округления.

Описание грамматики рекурсивного спуска:
- expr → add
- add → mul ((+|-) mul)*
- mul → pow ((*|/|//|%) pow)*
- pow → unary (** pow)?
- unary → (+|-) unary | primary
- primary → NUM | ( expr )

## Описание ошибок в порядке убывания их приоритета
<pre>
- NullExpressionError         # пустая строка
- NullNumberError             # нет числовых значений
- NullBracketError            # пустые скобки
- LotOperatorError            # два оператора и более стоят подряд
- SeamBracketsError           # стык скобок "(...)(...)", нет операции
- LotPointError               # две и более точки подряд в десятичной записи числа
- LastOperatorError           # выражение оканчивается на один из операроторов из константы ALL_OPERATORS
- FirstOperatorError          # бинарный оператор в начале выражения
- CountBracketError           # количество закрывающих и открывающих скобок не равное
- NotOperatorError            # бинарные операторы отсутсвуют
- InvalidCharacterError       # введен недопустимый символ
- UnderscoreError             # нижнее подчеркивание не между частями числа
</pre>

Следующие ошибки не имеют явного приоритета, что быстрее найдется при вычислении
арифметического выражения слева-направо, та ошибка и будет возвращена.

<pre>
- ValueError              # "прозапас", если какая-то ошибка в коде была не учтена 
- ZeroDivisionError       # деление на ноль
- IntegerOperationError   # попытка выполнить операцию % и // для вещественных чисел
- NegativeSqrtError       # попытка извлечь корень четной степени из отрицательного числа
- OverflowError           # полученное значение слишком большое
</pre>

## Особенности вводимого пользователем выражения
- Пробелы игнорируются
- Работа как с вещественными, так и целыми числами
- Число с унарной операцией обязательно заключено в кавычки.
- Унарная операция может стоять в начале выражения (скобки в таком случае можно опустить)

## Особенности калькулятора:
- Ввод зациклен, пока пользователь не введет 'exit' или 'выход' -- без учета регистра
- Вывод осуществляется в типе int для целых чисел и float для вещественных чисел (для которых можно при более 
2 знаках после запятой задать округление до какого-то знака)
- Все бинарные операторы обязательно должны быть прописаны, случаи похожие на "(...)(...)" считаются ошибкой
- Пользователь может вводить как запятую, так и точку для определения десятичной части вещественного числа

---

Я пока писал код:
![Муд](https://avatars.mds.yandex.net/i?id=0430bab43e050b187c31e0f7103b602a_l-3979039-images-thumbs&n=13)